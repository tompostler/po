jobs:

- job: DotnetBuild
  steps:

  - task: UseDotNet@2
    displayName: Use net10
    inputs:
      version: 10.x

  - powershell: |
      dotnet tool install nbgv --global --version 3.9.*;
      nbgv cloud --all-vars;
    displayName: nbgv

  - task: Cache@2
    displayName: NuGet package caching
    inputs:
      # Use major and minor version to poison the cache.
      key: '$(NBGV_VersionMajor) | $(NBGV_VersionMinor) | $(Build.SourcesDirectory)/Directory.Packages.props'
      restoreKeys: |
        $(NBGV_VersionMajor) | $(NBGV_VersionMinor)
      path: $(NUGET_PACKAGES)

  - task: DotNetCoreCLI@2
    displayName: Restore nuget packages
    inputs:
      command: restore
      projects: src/po.slnx

  - task: Docker@2
    inputs:
      containerRegistry: 6d165ea2-8078-41dd-baef-3f44bbc79e27
      command: login

  - task: DotNetCoreCLI@2
    displayName: Build and publish image (linux-x64)
    inputs:
      command: publish
      projects: src/po/po.csproj
      arguments: '--runtime linux-x64 /t:PublishContainer'
      zipAfterPublish: true
      modifyOutputPath: true


- job: TagSource
  dependsOn: DotnetBuild
  steps:
  - checkout: none
  - powershell: |
      # .DESCRIPTION
      # This is needed since VSTS "Tag build on success" is tagging ALL the builds. This, as a build task, can be conditionalized to only run on the master branches.
      # In order for this to work for a build/release phase, you MUST check the box to "Allow scripts to access OAuth token".
      # This script will succeed on Unauthorized, Duplicate Tag, and successful scenarios. This is by design.
      $tagUrl = "{0}{1}/_apis/git/repositories/{2}/refs?api-version=1.0" -f $env:SYSTEM_TEAMFOUNDATIONCOLLECTIONURI, $env:SYSTEM_TEAMPROJECT, $env:BUILD_REPOSITORY_NAME
      Write-Host "URL: $tagUrl"
      $newTag = @"
      [
        {
          "name": "refs/tags/$env:BUILD_BUILDNUMBER",
          "oldObjectId": "0000000000000000000000000000000000000000",
          "newObjectId": "$env:BUILD_SOURCEVERSION"
        }
      ]
      "@;
      $auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes((":{0}" -f $env:SYSTEM_ACCESSTOKEN)))
      $result = Invoke-RestMethod $tagUrl -Method POST -Body $newTag -ContentType "application/json" -Headers @{ Authorization = ("Basic {0}" -f $auth) }
      $result | ConvertTo-Json -Depth 100 | Out-Host
    condition: and(succeeded(), eq(variables['Build.Reason'], 'IndividualCI'))
    displayName: Tag source with build number
    env:
      # Have to explicitly map through to grant access
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
